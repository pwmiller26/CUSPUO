from geopandas import *
from shapely.geometry import Point
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from math import *

#Until this stuff is properly paralleized and fused with project_lidar.py, this script will serve to identify the buildings corresponding
#to each pixel in the Lidar generated images
#The basic procedure is simple: type in the relevant MapPluto files, plus the 3 arrays generated by project_lidar.py, in the spaces bloew
#for each pixel, we first cut a slice of mappluto which contains only buildings within 1000 feet of that pixel
#then use geopandas intersect feature to find which building this pixel is in, giving us a new image array
#which contains the corresponding BBL values to each pixel
#after that, a bit of noise reduction, and then we generate an array which contains the outlines of the buildings

#IMPORTANT - This is totally an ad hoc script I made, and isn't perfect or especially fast. Somebody should really finish up
#the BBL component of project_lidar, since that should run a lot faster and should be more accurate


###################################################################

#This is where you specify the files you want

#load up relevant MapPluto fil
manhattan = GeoDataFrame.from_file('Manhattan/MNMapPLUTO.shp')

print 'got map pluto'

#Load the arrays containing the x, y, and distance coordinates - these are made by project_lidar.py
x = np.load('WTCxgrid.npy')
y = np.load('WTCygrid.npy')
pixelgrid = np.load('WTCdistgrid.npy')

print 'loaded'




#######################################################################
#just to reduce computation time, first slice off buildings that are outside a box defined by the max and min x/y values taken by the data
manbox = manhattan[ manhattan.XCoord < 1.1*np.amax(x)]
manbox = manbox[ manhattan.YCoord < 1.1*np.amax(y)]
manbox = manbox[ manhattan.XCoord > 0.95*np.amin(x)]
manbox = manbox[ manhattan.YCoord > 0.95*np.amin(y)]


xmax = len(x)
ymax = len(x[0])
#bblgrid is an array that will store our bbl data
bblgrid = np.zeros(shape = x.shape)
for i in range(0, xmax):
    print i, xmax
    for j in range(0, ymax):
        #for each pixel, first we check to make sure it's spatial (as opposed to pixel) x coordinate is not -1
        #as that value means project_lidar didn't find any Lidar points at that pixel - it's just empty space
        if x[i][j] != -1:
            xi = x[i][j]
            yi = y[i][j]
            #slice out a circle containing buildings within a distance of 1000 feet from pixel
            cut = (manhattan.XCoord - xi)**2 + (manhattan.YCoord - yi)**2 < 1000**2
            man_cut = manhattan[cut] 
            shape = (Point(xi, yi))
            intersect = man_cut.contains(shape)
            #figure out if any buildings intersect our point, and if so record which one
            if any(intersect == True):
                building = man_cut[intersect]
                bblgrid[i][j] = int(building.BBL)

#remove those weird noise columns, by smoothing out any pixel whose BBL is not equal to that of either of its horizontal neighbors
for i in range(1, len(pixelgrid) - 1):
    for j in range(1, len(pixelgrid[0]) - 1):
        if bblgrid[i][j - 1] != bblgrid[i][j] and bblgrid[i][j] != bblgrid[i][j+1]:
            bblgrid[i][j] = bblgrid[i][j-1]
            pixelgrid[i][j] = 0.5*(pixelgrid[i][j-1] + pixelgrid[i][j+1])

#Make a new grid which has value 1 at pixels containing a building edge, and 0 otherwise
outline = np.zeros(pixelgrid.shape)
for i in range(0, len(pixelgrid) - 1):
    for j in range(0, len(pixelgrid[0]) - 1):
        if bblgrid[i][j]!= bblgrid[i + 1][j]:
            outline[i][j] = 1
            outline[i+1][j] = 1
        elif bblgrid[i][j] != bblgrid[i][j+1]:
            outline[i][j] = 1
            outline[i][j+1] = 1

outline = np.ma.masked_where(outline != 1, outline) #makes the points that aren't 1, and thus aren't edges, transparent when we plot
#this lets use make those nice overlayed images
